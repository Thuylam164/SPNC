<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    
    <meta name="csrf-token" content="lMBYwLdC01HDFIxxNd5qY9YNILEeJG4Xeo8ZtYht">
    <meta http-equiv="X-UA-Compatible" content="IE=EDGE">
    <title>Sorting (Merge Sort) - Sắp xếp Trộn</title>

    <link rel="stylesheet" href="https://visualgo.net/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="https://visualgo.net/fonts/silkscreen/stylesheet.css">
    <link rel="stylesheet" type="text/css" href="https://visualgo.net/css/common-1.0.2.css">
    <link rel="stylesheet" href="https://visualgo.net/css/viz-1.0.4.css">
    <link rel="stylesheet" href="https://visualgo.net/css/visual.css">
    <link rel="stylesheet" href="https://visualgo.net/css/drawgraph-1.0.2.css">
    <style>
    
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>

<style>
#create-userdefined-input input { width: 130px; }

text {
  fill: black;
  font: 20px sans-serif;
  text-anchor: middle;
}

text-alt {
  fill: black;
  font: 0px sans-serif;
  text-anchor: middle;
}

#viz-counting-sort-secondary-canvas {
  position: relative;
  top: -500px;
}

#viz-sort-index-canvas {
  position: relative;
  top: -395px;
}

#sort-viz {
  width: 100%;
  height: max(720px, 90vh);
  text-align: center;
  overflow: hidden;
  padding-top: 10px;
}
</style>
    
    <style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
  </head>

  <body>
    <div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
        <style>
  #topbar {
    background-color: rgb(3, 10, 13);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }


</style> 
<nav id="topbar">
    <span style="margin-right: 0.25rem">
      <a >
        <span style="color: white; font-size: 16px;">Mô phỏng thuật toán </span><span class="colour" style="font-size: 16px;">Sắp xếp trộn</span><span style="font-size: 40%; color: white"></span>
      </a>
    </span>
  
    <span style="max-height: 30px">
      <span id="title">
        <a id='title-Merge' style="font-size: 16px;">Merge Sort</a>
      </span>
    </span>
  
    <!-- Thêm phần Icon và "Trang chủ" ở góc phải -->
    <span style="position: absolute; right: 10px; top: 5px; display: flex; align-items: center;">
      <!-- Thêm biểu tượng -->
      <a href="trangchu.html" style="display: flex; align-items: center; text-decoration: none; font-size: 16px;">
        <img src="img/bieutuong.png" alt="Trang chủ" style="width: 40px; height: 40px; margin-right: 10px;">
        <!-- Thêm chữ Trang chủ -->
        <span style="color: lightblue;">Trang chủ</span>
      </a>
    </span>
  </nav>
  
<script>
  function changeURL() {
    let URL = window.location.href.split('/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "lMBYwLdC01HDFIxxNd5qY9YNILEeJG4Xeo8ZtYht",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>

      <div id="dark-overlay"></div>

      <div id="main-content-container" style="flex: 1">
        <!-- 4 Jan 2022: Manas, img/arrow_white_right.png is still here -->
    <div id="mobile-playback-overlay" class="playing" style="display: none;">
      <span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
      <span id="mobile-playback-rewind" class="mobile-playback-item" onclick=mobilePlaybackRewind()><img src="https://visualgo.net/img/prevFrame.png" alt="rewind 7 frames"></span>
      <span id="mobile-playback-pause" class="mobile-playback-item" onclick=mobilePlaybackPauseOrPlay()><img src="https://visualgo.net/img/pause.png" alt="pause"></span>
      <span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick=mobilePlaybackPauseOrPlay()><img src="https://visualgo.net/img/play.png" alt="play"></span>
      <span id="mobile-playback-forward" class="mobile-playback-item" onclick=mobilePlaybackForward()><img src="https://visualgo.net/img/nextFrame.png" alt="forward 7 frames"></span>
      <span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
    </div>
    <div id="status" class="panel"><p></p></div>
    <div id="status-hide" class="panel-hide"><img src="https://visualgo.net/img/arrow_white_right.png" alt=">" title="show/hide status panel"/></div>

    <div id="codetrace" class="panel">
      <p id="code1" style="padding-top: 10px;"></p>
      <p id="code2"></p>
      <p id="code3"></p>
      <p id="code4"></p>
      <p id="code5"></p>
      <p id="code6"></p>
      <p id="code7" style="padding-bottom: 10px;"></p>
    </div>
    <div id="codetrace-hide" class="panel-hide"><img src="https://visualgo.net/img/arrow_white_right.png" alt=">" title="show/hide codetrace panel"/></div>

    <div id="left-bar"></div>
    <div id="right-bar"></div>

    <div id="media-controls">
    <div id='speed-control'><div id='speed-input'></div><div id='viz-speed-value'>1x</div></div>
      <span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="https://visualgo.net/img/goToBeginning.png" alt="go to beginning"></span>
      <span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="https://visualgo.net/img/prevFrame.png" alt="previous frame"></span>
      <span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="https://visualgo.net/img/pause.png" alt="pause"></span>
      <span id="play" class="media-control-button" title="play" onclick=play()><img src="https://visualgo.net/img/play.png" alt="play"></span>
      <span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="https://visualgo.net/img/nextFrame.png" alt="next frame"></span>
      <span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="https://visualgo.net/img/goToEnd.png" alt="go to end"></span>
      <div id="progress-bar" class="media-control-button"></div>
    </div>


    <div id='e-lecture' class='panel'></div> <!-- to do soon: put all that have to appear/disappear together when div with id overlay is shown/hide, respectively -->
    <div id='e-lecture-timeline'></div>
    <div id='e-lecture-f1map'>
      <div class="e-lecture-f1map-sector" sectorNo=1></div>
      <div class="e-lecture-f1map-sector" sectorNo=2></div>
      <div class="e-lecture-f1map-sector" sectorNo=3></div>
    </div>
       

    <div id="dropdown-temp-holder" hidden></div>

    <div id="popup" hidden>
      <div id="popup-content"></div>
      <span id="hide-popup" hidden>X <u>Close</u></span>
    </div>

<div id="sort-viz">
  <svg id="viz"></svg><br>
  <svg id="viz-sort-index-canvas"></svg><br>
  <svg id="viz-counting-sort-secondary-canvas"></svg>
  <div id="viz-radix-sort-canvas">
    <span id="radix-sort-bucket-labels-collection">
      <span class="radix-sort-bucket-label" id="radix_base_0">0</span>
      <span class="radix-sort-bucket-label" id="radix_base_1">1</span>
      <span class="radix-sort-bucket-label" id="radix_base_2">2</span>
      <span class="radix-sort-bucket-label" id="radix_base_3">3</span>
      <span class="radix-sort-bucket-label" id="radix_base_4">4</span>
      <span class="radix-sort-bucket-label" id="radix_base_5">5</span>
      <span class="radix-sort-bucket-label" id="radix_base_6">6</span>
      <span class="radix-sort-bucket-label" id="radix_base_7">7</span>
      <span class="radix-sort-bucket-label" id="radix_base_8">8</span>
      <span class="radix-sort-bucket-label" id="radix_base_9">9</span>
      <span class="radix-sort-bucket-label" id="radix_base_A">A</span>
      <span class="radix-sort-bucket-label" id="radix_base_B">B</span>
      <span class="radix-sort-bucket-label" id="radix_base_C">C</span>
      <span class="radix-sort-bucket-label" id="radix_base_D">D</span>
      <span class="radix-sort-bucket-label" id="radix_base_E">E</span>
      <span class="radix-sort-bucket-label" id="radix_base_F">F</span>
    </span>
  </div>
</div>
<div id="current-action" class="panel"><p></p></div>
<!--?= console_log($extraCSS); ?-->


    <style>
        .create {
            bottom: 92px
        }
    </style>
    <style>
        .sort {
            bottom: 65px
        }
    </style>

<div id="actions" class="panel">
            <p id="create">Tạo(A)</p>
                <p class="execAction" id="sort" onClick="sortGeneric()">Sắp xếp</p>
    </div>
    <div id="actions-hide" class="panel-hide">
      <span style="color:white; font-size: x-large; display: inline-block;">></span>
  </div>
  <div id="actions-extras">
      <div class="create action-menu-pullout">
          <div id="create-userdefined-input-random" class="new-menu-option">
              Nhập N = <input id="user-arr-size" type="number" autocomplete="off" min="1" max="15" value="10" />
          </div>
          <div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="createList('random')">
              <p>Tạo ngẫu nhiên</p>
          </div>
          <div id="create-sorted" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras('create', 'create-sorted')">
              <p>Đã sắp xếp</p>
              <div id="create-sorted-third-tier" class="create-sorted-third-tier new-menu-option" style="display: none;">
                  <div id="create-sorted-non-increasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList('sorted-non-increasing')">
                      <p>Giảm dần</p>
                  </div>
                  <div id="create-sorted-non-decreasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList('sorted-non-decreasing')">
                      <p>Tăng dần</p>
                  </div>
              </div>
          </div>
          <div id="create-nearly-sorted" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras('create', 'create-nearly-sorted')">
              <p>Gần như đã sắp xếp</p>
              <div id="create-nearly-sorted-third-tier" class="create-nearly-sorted-third-tier new-menu-option" style="display: none;">
                  <div id="create-nearly-sorted-decreasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList('nearly-sorted-non-increasing')">
                      <p>GIảm dần</p>
                  </div>
                  <div id="create-nearly-sorted-increasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList('nearly-sorted-non-decreasing')">
                      <p>Tăng dần</p>
                  </div>
              </div>
          </div>
          <div id="create-many-duplicates" class="execAction new-menu-option coloured-menu-option" onClick="createList('many-duplicates')">
              <p>Nhiều bản sao</p>
          </div>
          <div id="create-userdefined-input" class="new-menu-option">
              A = <input id="userdefined-input" type="text" title="Enter a list of numbers, separated by commas." autocomplete="off" value="3,44,38,5,47,15,36,26,27,2,46,4,19,50,48" />
          </div>
          <div id="create-userdefined-go" class="execAction new-menu-option coloured-menu-option" onClick="createList('userdefined')">
              <p>Chạy</p>
          </div>
          <div id="create-userdefined-input-cs" class="new-menu-option" style="display: none;">
              (base) k = <input id="counting-sort-base" type="number" autocomplete="off" min="2" max="16" value="10" />
          </div>
          <div id="create-userdefined-go-cs" class="execAction new-menu-option coloured-menu-option" onClick="setBase()">
              <p>Set base</p>
          </div>
          <div id="create-userdefined-input-rs" class="new-menu-option" style="display: none;">
              (base) k = <input id="radix-sort-base" type="number" autocomplete="off" min="1" max="16" value="10" />
          </div>
          <div id="create-userdefined-go-rs" class="execAction new-menu-option coloured-menu-option" onClick="setBase()">
              <p>Set base</p>
          </div>
          <div id="create-err" class="err" style="float: left;"></div>
      </div>
  </div>
  
    <div class="sort action-menu-pullout">
            <div id="counting-simple" class="execAction new-menu-option coloured-menu-option" onClick="sort()" style="display: none" >
            <p>Simple</p>
            </div>
            <div id="counting-stable" class="execAction new-menu-option coloured-menu-option" onClick="countingSortStable()" style="display: none" >
            <p>Stable</p>
            </div>
            <div id="recursive-show-depth" class="execAction new-menu-option coloured-menu-option" onClick="recursiveSort(true)" style="display: none" >
            <p>Thể hiện chiều sâu</p>
            </div>
            <div id="recursive-hide-depth" class="execAction new-menu-option coloured-menu-option" onClick="recursiveSort(false)" style="display: none" >
            <p>Ẩn chiều sâu</p>
            </div>
            <div id="sort-err" class="err" style="float: left;"></div>
    </div>
</div>

      </div>

      <div id="bottom-bar">
      <a id="scale" style="display: none;">1.0x</a>
      <a id="trigger-about"></a>
  
    </div>
   
    </div>

   
    <script src="https://code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>

    <script>
  $(function () {
    // overlays stuffs
    
    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>

    <script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "lMBYwLdC01HDFIxxNd5qY9YNILEeJG4Xeo8ZtYht"
        }
      });
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

    </script>

    <script src="https://visualgo.net/js/jquery-ui.min.js"></script>
    
    <script src="https://visualgo.net/js/d3.min.js"></script>
    <script src="https://visualgo.net/js/viz-1.0.10.js"></script>

    <script src="/js/graph_library/constant.js"></script>
    <script src="/js/graph_library/drawgraph.js"></script>
    <script src="/js/graph_library/GraphTextWidget.js"></script>
    <script src="/js/graph_library/GraphEdgeWidget.js"></script>
    <script src="/js/graph_library/GraphPolygonWidget.js"></script>
    <script src="/js/graph_library/GraphVertexWidget.js"></script>
    <script src="/js/graph_library/GraphWidget.js"></script>
    <script src="/js/graph_library/helperObjects.js?refresh22aug9pm"></script> 
    <script src="/js/graph_library/misc.js"></script>
    <script src="/js/graph_library/properties.js"></script>
    <script src="/js/graph_library/Widget.js"></script>
    <script src="/js/graph_library/force_directed_library.js"></script>

    <script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);

        $('#scale').show();

        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
        $('#scale').show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }



      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "lMBYwLdC01HDFIxxNd5qY9YNILEeJG4Xeo8ZtYht",
            section: (sectorNum - 1),
            topic: "/sorting".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/sorting".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/sorting';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

      
      });

     
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }


      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>

<script type="text/javascript">
    var extraCSS = {"sort":"65px","create":"92px"};
    var actionsIds = {"create":{"p":"Create(A)","parents":["create-sorted","create-nearly-sorted","create-many-duplicates"]},"sort":{"p":"Sort","onClick":"sortGeneric()"}};
    var isOpens = {};
    var len = 2;
    var keys = ["create","sort"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('create');
                    closeAction('sort');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

   
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'create').click(function() {
            openAction('create');
                                                                            closeAction('sort');
                                    });
            $('#' + 'sort').click(function() {
            openAction('sort');
                                                closeAction('create');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// Sorting Widget
// original author: Ian Leow Tze Wei
// taken over by Steven on Sat 25 Dec 2021 Christmas day to fix randomize Quick Sort on (many) duplicates

var Sorting = function() {
  var computeInversionIndex = true; // Quick hack on 26 Dec 2021, it will be true from now onwards for Bubble and Merge sort...
  // constants
  var RADIX_CHANGE_BASE = "radix_change_base";

  var HIGHLIGHT_NONE = "lightblue";
  var HIGHLIGHT_STANDARD = "green";
  var HIGHLIGHT_SPECIAL = "#DC143C";
  var HIGHLIGHT_SORTED = "orange";

  var HIGHLIGHT_LEFT = "#3CB371";
  var HIGHLIGHT_RIGHT = "#9932CC";
  var HIGHLIGHT_PIVOT = "yellow";

  var HIGHLIGHT_GRAY = "#CCCCCC";

  var HIGHLIGHT_RAINBOW = [ // TODO: can consider making a function to generate a specturm of hex values depending on num of elements - Ting Xiao
    "#FF0000",
    "#FF4000",
    "#FF8000",
    "#FFBF00",
    "#FFFF00",
    "#BFFF00",
    "#80FF00",
    "#40FF00",
    //"#00FF00",
    "#00FF40",
    "#00FF80",
    "#00FFBF",
    "#00FFFF",
    "#00BFFF",
    "#0080FF",
    "#0040FF",
    "#0000FF",
    "#4000FF",
    "#8000FF",
    "#BF00FF",
    "#FF00FF"
  ];

  var HIGHLIGHT_BLUESHADES = [
    HIGHLIGHT_GRAY,
    HIGHLIGHT_NONE,
    "#9DC4E8",
    "#8EB1EB",
    "#7E9DED",
    "#6E89EF",
    "#5E76F1",
    "#4F62F4",
    "#3F4FF6",
    "#2F3BF8",
    "#1F27FA",
    "#1014FD",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF"
  ];

  var POSITION_USE_PRIMARY = "a";
  var POSITION_USE_SECONDARY_IN_DEFAULT_POSITION = "b";

  // offsets the y-axis by the offset set in yPosition.
  var POSITION_USE_Y_VALUE_PARAM = "!!use_y!!"

  // Objects definition
  var Entry = function(value, highlight, position, yPosition, secondaryPositionStatus) {
    this.value = value; // number
    this.highlight = highlight; // string, use HIGHLIGHT_ constants
    this.position = position; // number
    this.yPosition = yPosition; // number
    this.secondaryPositionStatus = secondaryPositionStatus; // integer, +ve for position overwrite, -ve for absolute postion (-1 for 0th absolution position)
  }

  var Backlink = function(value, highlight, entryPosition, yPosition, secondaryPositionStatus) {
    this.value = value; // number
    this.highlight = highlight; // string, use HIGHLIGHT_ constants
    this.entryPosition = entryPosition; // number
    this.yPosition = yPosition; // number
    this.secondaryPositionStatus = secondaryPositionStatus; // integer, +ve for position overwrite
  }

  var State = function(entries, backlinks, barsCountOffset, status, lineNo) {
    this.entries = entries; // array of Entry's
    this.backlinks = backlinks; // array of Backlink's
    this.barsCountOffset = barsCountOffset; // how many bars to "disregard" (+ve) or to "imagine" (-ve) w.r.t. state.entries.length when calculating the centre position
    this.status = status;
    this.lineNo = lineNo; //integer or array, line of the code to highlight
  }

  //Helpers
  var EntryBacklinkHelper = new Object();
  EntryBacklinkHelper.appendList = function(entries, backlinks, numArray) {
    for (var i = 0; i < numArray.length; ++i) {
      EntryBacklinkHelper.append(entries, backlinks, numArray[i]);
    }
  }

  EntryBacklinkHelper.append = function(entries, backlinks, newNumber) {
    entries.push(new Entry(newNumber, HIGHLIGHT_NONE, entries.length, 0, POSITION_USE_PRIMARY));
    backlinks.push(new Backlink(newNumber, HIGHLIGHT_NONE, backlinks.length, 0, POSITION_USE_PRIMARY));
  }

  EntryBacklinkHelper.update = function(entries, backlinks) {
    for (var i = 0; i < backlinks.length; ++i) {
      entries[backlinks[i].entryPosition].highlight = backlinks[i].highlight;
      entries[backlinks[i].entryPosition].position = i;
      entries[backlinks[i].entryPosition].secondaryPositionStatus = backlinks[i].secondaryPositionStatus;
      entries[backlinks[i].entryPosition].yPosition = backlinks[i].yPosition;
    }
  }

  EntryBacklinkHelper.copyEntry = function(oldEntry) {
    return new Entry(oldEntry.value, oldEntry.highlight, oldEntry.position, oldEntry.yPosition, oldEntry.secondaryPositionStatus);
  }

  EntryBacklinkHelper.copyBacklink = function(oldBacklink) {
    return new Backlink(oldBacklink.value, oldBacklink.highlight, oldBacklink.entryPosition, oldBacklink.yPosition, oldBacklink.secondaryPositionStatus);
  }

  EntryBacklinkHelper.swapBacklinks = function(backlinks, i, j) {
    var swaptemp = backlinks[i];
    backlinks[i] = backlinks[j];
    backlinks[j] = swaptemp;
  }

  var StateHelper = new Object();
  StateHelper.createNewState = function(numArray) {
    var entries = new Array();
    var backlinks = new Array();
    EntryBacklinkHelper.appendList(entries, backlinks, numArray);
    return new State(entries, backlinks, 0, "", 0);
  }

  StateHelper.copyState = function(oldState) {
    var newEntries = new Array();
    var newBacklinks = new Array();
    for (var i = 0; i < oldState.backlinks.length; ++i) {
      newEntries.push(EntryBacklinkHelper.copyEntry(oldState.entries[i]));
      newBacklinks.push(EntryBacklinkHelper.copyBacklink(oldState.backlinks[i]));
    }

    var newLineNo = oldState.lineNo;
    if (newLineNo instanceof Array)
      newLineNo = oldState.lineNo.slice();

    return new State(newEntries, newBacklinks, oldState.barsCountOffset, oldState.status, newLineNo);
  }

  StateHelper.updateCopyPush = function(list, stateToPush) {
    EntryBacklinkHelper.update(stateToPush.entries, stateToPush.backlinks);
    list.push(StateHelper.copyState(stateToPush));
  }

  var FunctionList = new Object();
  FunctionList.text_y = function(d) {
    var barHeight = scaler(d.value) + 3;
    if (barHeight < 35) return -15;
    return barHeight - 15;
  }

  // not used by radix sort at all 
  // changes y-axis of rectangle
  FunctionList.g_transform = function(d) {
    if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
      return 'translate(' + (centreBarsOffset + d.position * barWidth) + ", " + (maxHeight - scaler(d.value) - 3) + ')';
    else if (d.secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION)
      return 'translate(' + (centreBarsOffset + d.position * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value) - 3) + ')';
    else if (d.secondaryPositionStatus == POSITION_USE_Y_VALUE_PARAM)
      return 'translate(' + (centreBarsOffset + d.position * barWidth) + ", " + (maxHeight + d.yPosition - scaler(d.value) - 3) + ')';
    else if (typeof d.secondaryPositionStatus == "string")  // for stable counting sort
      return 'translate(' + (centreBarsOffset + Number(d.secondaryPositionStatus) * barWidth) + ", " + (maxHeight - scaler(d.value) - 3) + ')';
    else if (d.secondaryPositionStatus >= 0)
      return 'translate(' + (centreBarsOffset + d.secondaryPositionStatus * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value) - 3) + ')';
    else if (d.secondaryPositionStatus < 0)
      return 'translate(' + (counter_bar_offset[maxCountingSortElementValue - 1] + (d.secondaryPositionStatus * -1 - 3) * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value) - 3) + ')';
    else
      return 'translation(0, 0)'; // error
  }

  FunctionList.radixElement_left = function(d) {
    if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
      return d.position * 65 + centreBarsOffset + "px";
    return d.secondaryPositionStatus * 65 + 17.5 + "px";
  }

  FunctionList.radixElement_bottom = function(d, i) {
    if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
      return 500 - 24 + "px";
    //console.log(i + " " + radixSortBucketOrdering[i]);
    return radixSortBucketOrdering[i] * 30 + 105 + "px";
  }

  FunctionList.radixElement_html = function(d) {
    var text = (typeof d.highlight === 'string' && d.highlight.trim() == HIGHLIGHT_NONE)
                ? d.value
                : changeTextBasedOnRadixSortBase(d.value);

    if (typeof d.highlight === 'string') {
      if (d.highlight.endsWith(" "))
        text = "<span style='color: palevioletred;'>" + text + "</span>";
        return text;

      if (d.highlight.trim() == HIGHLIGHT_NONE)
        return text;
    }

    while (text.length != 4)
      text = " " + text;

    var positionToHighlight = 0; // positionToHighlight = log_to_base_10(d.highlight), assumes d.highlight is power of 10
    var positionCounter = d.highlight;
    while (positionCounter != 1) {
      positionToHighlight++;
      positionCounter /= 10;
    }

    positionToHighlight = 3 - positionToHighlight;

    if (text.charAt(positionToHighlight) != " ") {
      text = text.slice(0, positionToHighlight) +
             "<span style='color: #B40404;'>" +
             text.charAt(positionToHighlight) +
             "</span>" +
             text.slice(positionToHighlight+1);
    }

    text = text.trim();
    return text;
  }

  const numberMap = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
  var changeTextBasedOnRadixSortBase = function(value) {
    var result = [];

    if (value == 0) {
      return "0000";
    }

    while (value > 0) {
      currentValue = value % radixSortBase;
      result.push(numberMap[currentValue]);
      value = Math.floor(value / radixSortBase);
    }

    while ((radixSortBase !== 10) && (result.length < 4)) {
      result.push(numberMap[0]);
    }

    return result.reverse().join("");
  }

  var makePaler = function(hexColor) {
    var red = Math.floor(parseInt(hexColor.slice(1, 3), 16) + 150);
    var green = Math.floor(parseInt(hexColor.slice(3, 5), 16) + 150);
    var blue = Math.floor(parseInt(hexColor.slice(5, 7), 16) + 150);

    if (red > 255) red = 255;
    if (green > 255) green = 255;
    if (blue > 255) blue = 255;

    red = red.toString(16);
    green = green.toString(16);
    blue = blue.toString(16);

    if (red.length == 1) red = "0" + red;
    if (green.length == 1) green = "0" + green;
    if (blue.length == 1) blue = "0" + blue;
    return "#" + red + green + blue;
  }

  // Variables/Settings
  this.currentNumList = [29, 10, 14, 37, 14]; // the default
  var isMediumScale = false;
  var barWidth = 50;
  var maxHeight = 230;
  var gapBetweenBars = 5;
  var maxNumOfElements = 18; // dropped from 20 to 15 on 25 Feb, changed to 18 on 18 Mar (otherwise too far left after mobile design integration) - 50 is used for medium-scale viz as of now
  var gapBetweenPrimaryAndSecondaryRows = 100; // 30; // of the bars
  var numOfElements = 10;

  const counter_bar_offset = [300, 275, 250, 225, 200, 175, 150, 125, 100, 75, 50, 25, 0, -25, -50];
  const index_bar_offset = [425, 400, 375, 350, 325, 300, 275, 250, 225, 200, 175, 150, 125, 100, 75, 50, 25, 0];
  var maxCountingSortElementValue = 9; 
  var radixSortBase = 10;
  const maxRadixSortElements = 12;
  var maxRadixSortElementValue = 9999; // Note that this isn't really customizable, as the code for radix sort is written with this value = 9999 in mind.
  var maxElementValue = 50; // for all other sorts - this is fully customizable (seriously)

  var graphElementSize = 10; // The width of the square in the side-graph representing 1 element
  var graphElementGap = 2; // The width of the gap between each element in the side-graph
  var graphRowGap = 10; // The height of the gap between each row in the side graph

  //Code body
  var statelist = new Array();
  var secondaryStatelist = new Array();
  var transitionTime = 500;
  var currentStep = 0;
  var animInterval;
  var issPlaying; //so named so as not to mess with the isPlaying in viz.js

  var quickSortUseRandomizedPivot; //true-false flag
  var mergeSortInversionIndexCounter; //used by merge sort to count the inversion index
  var centreBarsOffset; // x offset to centre the bars in the canvas
  var radixSortBucketOrdering; // used to order the elements inside each bucket (for radix sort). for formatting purposes.

  var showRecursionTree = true; // I'm a bit sad that this is a global state, but it's the easiest way to get it working.

  var isRadixSort = false;
  var isCountingSort = false;

  this.selectedSortFunction;
  // this.useEnhancedBubbleSort = false;
  // this.computeInversionIndex = false; // Quick hack on 26 Dec 2021, it will be true from now onwards for Bubble and Merge sort...

  var canvas = d3.select("#viz")
                 .attr("height", maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows)
                 .attr("width", barWidth * maxNumOfElements);

  var countingSortSecondaryCanvas = d3.select("#viz-counting-sort-secondary-canvas")
                                      .attr("height", 30) // 25 Feb, previously 60
                                      .attr("width", barWidth * maxNumOfElements);

  var sortIndexCanvas = d3.select("#viz-sort-index-canvas")
                          // No longer 30 due to shifting of text.
                          .attr("height", maxHeight + gapBetweenPrimaryAndSecondaryRows + 30)
                          .attr("width", barWidth * maxNumOfElements);

  var radixSortCanvas = d3.select("#viz-radix-sort-canvas");

  var scaler = d3.scale
                 .linear()
                 .range([0, maxHeight]);

  var drawState = function(stateIndex) {
    if (isCountingSort)
      maxHeight = 160; // make the bars shorter by half for counting sort
    else
      maxHeight = 230;

    // refresh scaler function
    scaler = d3.scale.linear().range([0, maxHeight]);

    if (isRadixSort)
      drawRadixSortCanvas(statelist[stateIndex], secondaryStatelist[stateIndex]);
    else
      drawBars(statelist[stateIndex]);

    $('#status p').html(statelist[stateIndex].status);
    highlightLine(statelist[stateIndex].lineNo);

    drawIndexCounters(statelist[stateIndex]);
    if (isCountingSort)
      drawCountingSortCounters(secondaryStatelist[stateIndex]);

  };

  var drawBars = function(state) {
    scaler.domain([0, d3.max(state.entries, function(d) {
      return d.value + 3;
    })]);

    centreBarsOffset = (maxNumOfElements - (state.entries.length - state.barsCountOffset)) * barWidth / 2;

    var canvasData = canvas.selectAll("g").data(state.entries);

    // Exit ==============================
    var exitData = canvasData.exit()
                             .remove();

    // Entry ==============================
    var newData = canvasData.enter()
                            .append("g")
                            .attr("transform", FunctionList.g_transform);

    newData.append("rect")
           .attr("height", 0)
           .attr("width", 0);

    newData.append("text")
           .attr("dy", ".35em")
           .attr("x", (barWidth - gapBetweenBars) / 2)
           .attr("y", FunctionList.text_y)
           .text(function(d) {
             return d.value;
           });

    // Update ==============================
    canvasData.select("text")
              .transition()
              .attr("y", FunctionList.text_y)
              .text(function(d, i) {
                return d.value;
              });

    canvasData.select("rect")
              .transition()
              .attr("height", function(d) {
                return scaler(d.value) + 3;
              })
              .attr("width", barWidth - gapBetweenBars)
              .style("fill", function(d) {
                if (d.highlight.endsWith(" ")) {
                  return "palevioletred";
                }
                return d.highlight.trim();
              });

    canvasData.transition()
              .attr("transform", FunctionList.g_transform)

    if (isMediumScale) {
      canvas.selectAll("g").select("text").style("font-size", "0px");
    }
  };

  var drawCountingSortCounters = function(state) {
    // draws the numbers for the counting sort rectangles
    var canvasData;
    if (state == null)
      canvasData = countingSortSecondaryCanvas.selectAll("text").data([]);
    else
      canvasData = countingSortSecondaryCanvas.selectAll("text").data(state);

    // Exit ==============================
    var exitData = canvasData
            .exit()
            .remove();

    // Entry ==============================
    var newData = canvasData
            .enter()
            .append("text")
            .attr("dy", ".35em")
            .attr("x", function(d, i) {
              return counter_bar_offset[maxCountingSortElementValue - 1] + (i + 2) * barWidth + (barWidth - gapBetweenBars) / 2;
            })
            .attr("y", function(d) {
              return isMediumScale ? 20 : 10;
            })
            .text(function(d) {
              return d;
            });

    // Update ==============================
    canvasData
            .transition()
            .text(function(d) {
              return d;
            });

    if (isMediumScale) {
      countingSortSecondaryCanvas.selectAll("text").style("font-size", "15px");
    } else {
      countingSortSecondaryCanvas.selectAll("text").style("font-size", "20px");
    }
  };

  var drawIndexCounters = function(state) {
    if (isMediumScale) {
      return ;
    }

    var canvasData = sortIndexCanvas.selectAll("text").data(state.entries);
    var element = document.getElementById("viz-sort-index-canvas");
    element.style.top = isCountingSort ? "-395px" : "-325px";
    // element.style.left = `${index_bar_offset[numOfElements - 1]}px`;

    // This is based on "g_transform" implementation.
    // TODO: Clean this up?
    var computeYOffset = function(entry) {
      if (entry.secondaryPositionStatus == POSITION_USE_PRIMARY) {
        return 10;
      }
      else if (entry.secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION) {
        return 10 + maxHeight + gapBetweenPrimaryAndSecondaryRows;
      }
      else if (entry.secondaryPositionStatus == POSITION_USE_Y_VALUE_PARAM) {
        return 10 + entry.yPosition;
      }
      else if (typeof entry.secondaryPositionStatus == "string") {
        return 10;
      }
      else if (entry.secondaryPositionStatus >= 0 || entry.secondaryPositionStatus < 0) {
        return 10 + maxHeight + gapBetweenPrimaryAndSecondaryRows;
      }
      else {
        return 10;
      }
    }

    var computeXOffset = function(entry, i) {
      if (entry.secondaryPositionStatus == POSITION_USE_PRIMARY 
          || entry.secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION 
          || entry.secondaryPositionStatus == POSITION_USE_Y_VALUE_PARAM) {  
        return centreBarsOffset + entry.position * barWidth + (barWidth - gapBetweenBars) / 2;
      }
      else if (entry.secondaryPositionStatus >= 0) {
        return centreBarsOffset + entry.secondaryPositionStatus * barWidth + (barWidth - gapBetweenBars) / 2;
      }
      else if (entry.secondaryPositionStatus < 0) {
        return counter_bar_offset[maxCountingSortElementValue - 1] + (entry.secondaryPositionStatus * -1 - 3) * barWidth + (barWidth - gapBetweenBars) / 2;
      } 
      else if (typeof entry.secondaryPositionStatus == "string") {
        return centreBarsOffset + Number(entry.secondaryPositionStatus) * barWidth + (barWidth - gapBetweenBars) / 2;
      }
      else {
        return centreBarsOffset + entry.position * barWidth + (barWidth - gapBetweenBars) / 2;
      }
    }

    var computeText = function(entry, i) {
      if (entry.secondaryPositionStatus == POSITION_USE_PRIMARY 
          || entry.secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION 
          || entry.secondaryPositionStatus == POSITION_USE_Y_VALUE_PARAM) {
        return entry.position;
      }
      else if (entry.secondaryPositionStatus >= 0) {
        return entry.secondaryPositionStatus;
      }
      else if (entry.secondaryPositionStatus < 0) {
        // This is the stable counting sort case, we don't want to show it in this case.
        return "";
      } 
      else if (typeof entry.secondaryPositionStatus == "string") {
        return Number(entry.secondaryPositionStatus);
      } 
      else {
        return entry.position;
      }
    }

    // Exit ==============================
    var exitData = canvasData
            .exit()
            .remove();

    // Entry ==============================
    var newData = canvasData
            .enter()
            .append("text")
            .attr("dy", ".35em")
            .attr("x", computeXOffset)
            .attr("y", computeYOffset)
            .text(computeText);

    // Update ==============================
    canvasData
            .transition()
            .text(computeText)
            .attr("dy", ".35em")
            .attr("x", computeXOffset)
            .attr("y",  computeYOffset);
  };

  var drawRadixSortCanvas = function(state, secondaryState) {
    centreBarsOffset = (1000 - (state.entries.length * 65 - 10)) / 2; // uh, it's not really bars now, but just reusing the variable - same concept still
    var canvasData = radixSortCanvas.selectAll("div").data(state.entries);
    var radixSortBucketCount = new Array(radixSortBase).fill([]);
    radixSortBucketOrdering = new Array(state.backlinks.length);

    for (var i = 0; i < state.backlinks.length; ++i) {
      if (state.backlinks.secondaryPositionStatus != POSITION_USE_PRIMARY)
        radixSortBucketOrdering[state.backlinks[i].entryPosition] = radixSortBucketCount[state.backlinks[i].secondaryPositionStatus]++;
    }

    // Handle the buckets' DIV's
    if (secondaryState) {
      $("#radix-sort-bucket-labels-collection").show();
      for (var i = 0; i <= 15; i++) {
        $(`#radix_base_${numberMap[i]}`).show();
      }

      // only display the buckets that are being used for radix sort based on the chosen base
      for (var i = radixSortBase; i <= 15; i++) {
        $(`#radix_base_${numberMap[i]}`).hide();
      }
    }
    else {
      $("#radix-sort-bucket-labels-collection").hide();
    }

    // Exit ==============================
    var exitData = canvasData.exit()
                             .remove();

    // Entry ==============================
    var newData = canvasData.enter()
                            .append("div")
                            .classed({"radix-sort-element": true})
                            .style({
                              "left": FunctionList.radixElement_left,
                              "bottom": FunctionList.radixElement_bottom
                            })
                            .html(FunctionList.radixElement_html);

    // Update ==============================
    canvasData.html(FunctionList.radixElement_html)
              .transition()
              .style({
                "left": FunctionList.radixElement_left,
                "bottom": FunctionList.radixElement_bottom
              });
  };

  var generateRandomNumberArray = function(size, limit) {
    var numArray = new Array();
    for (var i = 0; i < size; ++i) {
      // resurrect 0 into the scale
      numArray.push(generateRandomNumber(0, limit));
    }
    return numArray;
  };

  var generateRandomNumber = function(min, max) { // generates a random integer between min and max (both inclusive)
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  var convertToNumber = function(num) {
    return +num;
  };

  this.changeBarWidth = function(width) {
    // 1. sets a new barWidth value
    // 2. redraws the visualisation
    // possibly split this function in 2 - 1 for shrinking 1 for reverting to default size
    if (isRadixSort) { // don't do anything for radix since it's different
        return;
    }

    barWidth = width;
    if (width >= 50) {
        gapBetweenBars = 5;
        maxNumOfElements = 18;
        isMediumScale = false;
    } else {
        gapBetweenBars = 13;
        maxNumOfElements = 43;
        isMediumScale = true;
    }

    if (width >= 50) {
        canvas.selectAll("g").select("text").style("font-size", "20px").attr("x", (barWidth - gapBetweenBars) / 2);
    } else {
        canvas.selectAll("g").select("text").style("font-size", "0px");
    }

  }

  this.createList = function(type, n) {
    // user input cannot be negative
    if (n <= 0) {
      $("#create-err").html('Bạn chỉ có thể nhập số dương.');
        return false;
    }
    else if (n > 43) {
      $("#create-err").html('Giá trị lớn nhất của n là 43');
        return false;
    }

    // var numArrayMaxListSize = isMediumScale ? 50 : 15; // on 25 Feb 2022, I lower this from 20 down to 15... (to make it nicer on mobile)
    var numArrayMaxListSize = n;
    var numArrayMaxElementValue = maxElementValue;
    if (this.selectedSortFunction == this.radixSort) {
      if (n > maxRadixSortElements) {
        $("#create-err").html('Bạn không thể có nhiều hơn {maxSize} phần tử!'.replace("{maxSize}", maxRadixSortElements));
          return false;
      }

      numArrayMaxElementValue = maxRadixSortElementValue;
    }
    else if (this.selectedSortFunction == this.countingSort) {
      numArrayMaxElementValue = maxCountingSortElementValue;
    }

    // using default scale, maximum number of bars that can be displayed is 18
    if (numArrayMaxListSize > 18) {
      setMediumScale();
    } else {
      setDefaultScale();
    }

    // setDefaultScale turns the index-viz on, we should turn it back off.
    if (this.selectedSortFunction == this.radixSort) {
      $('#viz-sort-index-canvas').hide();
    }

    var numArray = generateRandomNumberArray(numArrayMaxListSize, numArrayMaxElementValue);
    if (type.indexOf("many") != -1) {
      var range = generateRandomNumber(1, 4); // 1, 2, 3, or 4 different numbers only
      numArray = generateRandomNumberArray(numArrayMaxListSize, range);
    }

    numOfElements = numArrayMaxListSize;

    switch (type) {
      case 'random':
      case 'many-duplicates':
        break; // already done above
      case 'sorted-non-decreasing':
      case 'nearly-sorted-non-decreasing':
        numArray.sort(d3.ascending);
        break;
      case 'sorted-non-increasing':
      case 'nearly-sorted-non-increasing':
        numArray.sort(d3.descending);
        break;
      case 'userdefined':
        numArray = $('#userdefined-input').val().split(",");

        if ((this.selectedSortFunction == this.radixSort) && (numArray.length > maxRadixSortElements)) {
          $("#create-err").html('You can&#39;t have more than {maxSize} elements!'.replace("{maxSize}", maxRadixSortElements));
          return false;
        }

        for (var i = 0; i < numArray.length; ++i) {
          var temp = convertToNumber(numArray[i]);

          if (numArray[i].trim() == "") {
            $("#create-err").html('There seems to be a missing element (a duplicate comma somewhere perhaps?)');
            return false;
          }
          if (isNaN(temp)) {
            $("#create-err").html('There seems to be an invalid element (not a number): {num}.'.replace("{num}", numArray[i]));
            return false;
          }
          if (temp < 0 || temp > numArrayMaxElementValue) {
            $("#create-err").html(`Sorry, you're restricted to values between 0 and ${numArrayMaxElementValue} inclusive. (Out of range number: ${numArray[i]}.)`);
            return false;
          }

          numArray[i] = convertToNumber(numArray[i]);
        }

        numOfElements = numArray.length;

        if (numArray.length > 18) {
          setMediumScale();
        } else {
          setDefaultScale();
        }
        break;
    }

    if (type.indexOf("nearly") != -1) {
      // To make the list nearly sorted, we take the already sorted list and make swaps
      // such that the list becomes not sorted. The number of such swaps varies from 1 to 2 (customizable).
      // The idea is that the more swaps we make, the less "sorted" the list is.
      //
      // Another limitation is that each swap occurs between elements that are at most 3 positions away.
      while (true) {
        var newNumArray = numArray.slice();

        var numOfSwaps = generateRandomNumber(1, 2);
        for (var i = 0; i < numOfSwaps; ++i) {
          var firstSwappingIndex = generateRandomNumber(0, newNumArray.length - 4);
          var secondSwappingIndex = generateRandomNumber(1, 3) + firstSwappingIndex;

          var temp = numArray[firstSwappingIndex];
          newNumArray[firstSwappingIndex] = numArray[secondSwappingIndex];
          newNumArray[secondSwappingIndex] = temp;
        }

        // We compare the numArray with newNumArray, if they're are the same,
        // we try again, else we reassign numArray to newNumArray and break.
        var isEquals = true;
        for (var i = 0; i < numArray.length; ++i) {
          if (numArray[i] != newNumArray[i]) {
            isEquals = false;
            break;
          }
        }

        if (!isEquals) {
          numArray = newNumArray;
          break;
        }
      }
    }

    this.loadNumberList(numArray);
  }

  this.loadNumberList = function(numArray) {
    $("#create-err").html("");

    issPlaying = false;
    currentStep = 0;
    this.currentNumList = numArray;

    //console.log("numArray: " + numArray);

    statelist = [StateHelper.createNewState(numArray)];
    secondaryStatelist = [null]; // the initial secondary state will be an empty state
    drawState(0);
  }

  this.setSelectedSortFunction = function(f) {
    this.selectedSortFunction = f;
    isRadixSort = (this.selectedSortFunction == this.radixSort);
    isCountingSort = (this.selectedSortFunction == this.countingSort);
  }

  this.setCountingSortBase = function(k) {
    if (k < 2 || k > 16) {
      $("#create-err").html("Sorry, you're restricted to values between 2 and 16 inclusive.");
        return false;
    }
    
    maxCountingSortElementValue = k - 1;
    return true;
  }

  this.setRadixSortBase = function(k) {    
    if (k < 2 || k > 16) {
      $("#create-err").html("Sorry, you're restricted to values between 2 and 16 inclusive.");
        return false;
    }
    
    radixSortBase = k;
    maxRadixSortElementValue = Math.pow(k, 3);
    return true;
  }

  this.sort = function(callback) {
    return this.selectedSortFunction(callback);
  }

  this.getRadixSortHighlight = function(value) {
    return Math.pow(10, Math.floor(Math.log10(value) / Math.log10(radixSortBase)));
  }

  this.radixSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    secondaryStatelist = [false]; // showBucket flag - if true, shows the DIV's representing the bucketss
    var currentPlacing = 1;
    var targetPlacing = 1;

    var backlinkBuckets = [];
    for (var i = 0; i <= radixSortBase; i++) {
      backlinkBuckets.push([]);
    }

    var maxValue = d3.max(state.backlinks, function(d) {
      return d.value;
    });

    // decide on targetPlacing based on the value of the base, originally 10
    while (maxValue >= radixSortBase) {
      targetPlacing *= radixSortBase;
      maxValue = Math.floor(maxValue / radixSortBase);
    }
    // targetPlacing = ones/tens/hundreds/thousands place

    const line_no_offset = radixSortBase == 10 ? 1 : 0;
    if (radixSortBase != 10) {

      // two additional lines of code for change of base
      populatePseudocode([
        'for each e in list, change e from base 10 to base {k}'.replace("{k}", radixSortBase),
        'create 10 buckets (queues) for each digit (0 to 9)'.replace("10", radixSortBase).replace("9", radixSortBase - 1),
        'for each digit placing',
        ' for each e in list, move e into its bucket',
        '   for each bucket b, starting from smallest digit',
        '     while b is non-empty, restore e to list',
        'for each e in list, change e from base {k} to base 10'.replace("{k}", radixSortBase)
      ]);

      // change the base representation for the elements from base 10 to base k
      for (var i = 0; i < numElements; ++i) {
        state.backlinks[i].highlight = RADIX_CHANGE_BASE + " ";
        
        if (i > 0) {
          state.backlinks[i - 1].highlight = RADIX_CHANGE_BASE;
        }

        var v = state.backlinks[i].value;
        state.lineNo = [1];
        state.status = '{v} in base {radixSortBase} is {vSwitchBase}'.replace("{v}", v).replace("{radixSortBase}", radixSortBase).replace("{vSwitchBase}", changeTextBasedOnRadixSortBase(v));

        StateHelper.updateCopyPush(statelist, state);
        secondaryStatelist.push(true);
      }

    } else {

      // remove the lines of code that describe the change of base for base 10
      populatePseudocode([
        'create 10 buckets (queues) for each digit (0 to 9)'.replace("10", radixSortBase).replace("9", radixSortBase - 1),
        'for each digit placing',
        ' for each e in list, move e into its bucket',
        '   for each bucket b, starting from smallest digit',
        '     while b is non-empty, restore e to list'
      ]);
    }

    state.backlinks[numElements - 1].highlight = RADIX_CHANGE_BASE;
    state.lineNo = 2 - line_no_offset;
    state.status = "";

    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(true);

    for (; currentPlacing <= targetPlacing; currentPlacing *= radixSortBase) {
      for (var i = 0; i < numElements; ++i)
        state.backlinks[i].highlight = this.getRadixSortHighlight(currentPlacing);

      state.lineNo = 3 - line_no_offset;
      state.status = 'Processing the {currentPlacing} index'.replace('{currentPlacing}', currentPlacing == 1 ? '4th' : currentPlacing == 2 ? '3rd' : currentPlacing == 3 ? '2nd' : '1st');
      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(true);

      // iterate through for each element
      for (var i = 0; i < numElements; ++i) {
        var currentDigit = Math.floor(state.backlinks[i].value / currentPlacing) % radixSortBase;
        state.backlinks[i].secondaryPositionStatus = currentDigit;
        backlinkBuckets[currentDigit].push(state.backlinks[i]);
        state.lineNo = [(4 - line_no_offset)];
        state.status = 'Moving {val} to bucket no {bucket}'.replace('{val}', state.backlinks[i].value).replace('{bucket}', currentDigit);
        StateHelper.updateCopyPush(statelist, state);
        secondaryStatelist.push(true);
      }

      for (var i = 0, j = 0; i <= radixSortBase - 1; ) {
        if (backlinkBuckets[i].length == 0) {
          ++i;
          continue;
        }

        state.backlinks[j++] = backlinkBuckets[i].shift();
      }

      for (var i = 0; i < numElements; ++i) {
        state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;
        state.lineNo = [(5 - line_no_offset), (6 - line_no_offset)];
        state.status = 'Restoring element to position {i} in the list'.replace('{i}', i); // + state.backlinks[i]; //[i].secondaryPositionStatus;
        StateHelper.updateCopyPush(statelist, state);
        secondaryStatelist.push(true);
      }
    }

    // gradually change the base representation for the elements back to base 10
    for (var i = 0; i < numElements; ++i) {
      state.backlinks[i].highlight = HIGHLIGHT_NONE;

      if (radixSortBase != 10) {
        // skip the gradual change if sorting base = 10
        state.backlinks[i].highlight += " ";

        if (i > 0) {
          state.backlinks[i - 1].highlight = HIGHLIGHT_NONE;
        }

        var v = state.backlinks[i].value;
        state.lineNo = [7];
        state.status = '{vSwitchBase} back in base 10 is {v}'.replace("{vSwitchBase}", changeTextBasedOnRadixSortBase(v)).replace("{v}", v);

        StateHelper.updateCopyPush(statelist, state);
        secondaryStatelist.push(true);
      }
    }

    state.backlinks[numElements - 1].highlight = HIGHLIGHT_NONE;

    state.lineNo = [];
    state.status = 'We are done';
    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(false);

    this.play(callback);
    return true;
  }

  this.countingSort = function(callback) {
    // Note that while we have the maxCountingSortElementValue variable, it isn't really customizable.
    // The code here written is really just for the range 1 to 9.

    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'create key (counting) array',
      'for each element in list',
      '  increase the respective counter by 1',
      'for each counter, starting from smallest key',
      '  while counter is non-zero',
      '    restore element to list',
      '    decrease counter by 1'
    ]);

    var secondaryState = new Array(maxCountingSortElementValue + 1).fill(0);
    var backlinkBuckets = [];

    for (var i = 0; i <= maxCountingSortElementValue; i++) {
      backlinkBuckets.push([]);
    }

    state.barsCountOffset = maxCountingSortElementValue + 1;

    for (var i = 0; i <= maxCountingSortElementValue; ++i) {
      EntryBacklinkHelper.append(state.entries, state.backlinks, i);
      state.backlinks[numElements+i].highlight = HIGHLIGHT_GRAY;
      state.backlinks[numElements+i].secondaryPositionStatus = i * -1 - 5;
    }

    state.lineNo = 1;
    state.status = 'Create the key (counting) array (from 1 to 9).';

    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(secondaryState.slice()); // copy the array and push it into the secondary statelist

    for (var i = 0; i < numElements; ++i) {
      var currentValue = state.backlinks[i].value;

      backlinkBuckets[currentValue].push(state.backlinks[i]);

      state.backlinks[i].secondaryPositionStatus = currentValue * -1 - 5;

      ++secondaryState[currentValue];

      state.backlinks[currentValue + numElements].highlight = HIGHLIGHT_BLUESHADES[secondaryState[currentValue]];

      state.lineNo = [2, 3];
      state.status = 'Increase the counter with key {curVal} by 1.'.replace("{curVal}", currentValue);

      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(secondaryState.slice()); // copy the array and push it into the secondary statelist
    }

    for (var i = 0, j = 0; i <= maxCountingSortElementValue; ) {
      if (backlinkBuckets[i].length == 0) {
        ++i;
        continue;
      }

      state.backlinks[j++] = backlinkBuckets[i].shift();
    }

    for (var i = 0; i < numElements; ++i) {
      var currentValue = state.backlinks[i].value;

      state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;

      --secondaryState[currentValue];

      state.backlinks[currentValue+numElements].highlight = HIGHLIGHT_BLUESHADES[secondaryState[currentValue]];

      state.lineNo = [4, 5, 6, 7];
      state.status = 'Restore element {curVal}, and decrease the counter with that key by 1.'.replace("{curVal}", currentValue);

      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(secondaryState.slice()); //copy the array and push it into the secondary statelist
    }

    state.barsCountOffset = 0;

    for (var i = 0; i <= maxCountingSortElementValue; ++i) {
      state.entries.pop();
      state.backlinks.pop();
    }

    state.lineNo = 0;
    state.status = 'List is sorted!';
    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(null); //copy the array and push it into the secondary statelist

    this.play(callback);
    return true;
  }

  this.countingSortStable = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    var input_array = [];
    for (var i = 0; i < numElements; i++) {
      input_array.push(state.backlinks[i].value);
    }

    populatePseudocode([
      `A: [${input_array.toString()}]`,
      'create key (counting) array, C',
      'for each element el in list, C[el] = C[el] + 1',
      'getPrefixSum()',
      'for each element in list, starting from last',
      '  restore element to list to position C[el] ',
      '  C[el] = C[el] - 1'
    ]);

    var secondaryState = new Array(maxCountingSortElementValue + 1).fill(0);
    var backlinkBuckets = [];

    for (var i = 0; i <= maxCountingSortElementValue; i++) {
      backlinkBuckets.push([]);
    }

    state.barsCountOffset = maxCountingSortElementValue + 1;

    for (var i = 0; i <= maxCountingSortElementValue; ++i) {
      EntryBacklinkHelper.append(state.entries, state.backlinks, i);
      state.backlinks[numElements+i].highlight = HIGHLIGHT_GRAY;
      state.backlinks[numElements+i].secondaryPositionStatus = i * -1 - 5;
    }

    state.lineNo = 2;
    state.status = 'Create the key (counting) array (from 1 to 9).';

    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(secondaryState.slice()); // copy the array and push it into the secondary statelist

    for (var i = 0; i < numElements; ++i) {
      // state.backlinks store the value of the element at the ith position
      var currentValue = state.backlinks[i].value;
      // store the rectangle state with value i into backlinkBuckets[i - 1]
      backlinkBuckets[currentValue].push(state.backlinks[i]);

      state.backlinks[i].secondaryPositionStatus = currentValue * -1 - 5;
      // increment the counter values in secondaryState
      ++secondaryState[currentValue];
      // highlight the backlink based on the number of elements
      state.backlinks[currentValue + numElements].highlight = HIGHLIGHT_BLUESHADES[secondaryState[currentValue]];

      state.lineNo = [3];
      state.status = 'Increase the counter with key {curVal} by 1.'.replace("{curVal}", currentValue);

      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(secondaryState.slice()); // copy the array and push it into the secondary statelist
    }

    var colourArray = new Array(maxCountingSortElementValue + 1).fill(0);
    colourArray[0] = secondaryState[0];

    // prefixSum for stable sort and highlight the rectangles that are being summed
    for (var i = 1; i <= maxCountingSortElementValue; ++i) {
      colourArray[i] = secondaryState[i];
      secondaryState[i] += secondaryState[i - 1];

      // add a " " at the back to signal to highlight another colour, can change to another more special character
      state.backlinks[i + numElements].highlight += " ";
      state.backlinks[i - 1 + numElements].highlight += " ";

      if (i > 1) {
        state.backlinks[i - 2 + numElements].highlight = state.backlinks[i - 2 + numElements].highlight.trim();
      }
      
      state.lineNo = [4];
      state.status = `C[${i}] += C[${i - 1}].`;

      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(secondaryState.slice());
    }

    // remove the pink highlight and change it back to the original blue highlight
    for (var i = 0; i <= maxCountingSortElementValue; ++i) {
      state.backlinks[i + numElements].highlight = state.backlinks[i + numElements].highlight.trim();
    }

    state.lineNo = [];
    state.status = "";
    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(secondaryState.slice());

    const occurrence_suffix = ["st", "nd", "rd"];
    for (var i = numElements - 1; i >= 0; --i) {
      var currentValue = state.backlinks[i].value;

      --secondaryState[currentValue];
      colourArray[currentValue]--;

      state.backlinks[i].secondaryPositionStatus = secondaryState[currentValue].toString();

      state.backlinks[currentValue+numElements].highlight = HIGHLIGHT_BLUESHADES[colourArray[currentValue]];

      state.lineNo = [5, 6, 7];

      var occurrence = colourArray[currentValue] < 3 ? occurrence_suffix[colourArray[currentValue]] : "th";
      occurrence = (colourArray[currentValue] + 1) + occurrence;

      var get_occurrence_eq = currentValue > 0
                                ? `C[${currentValue}] - C[${currentValue - 1}]`
                                : `C[${currentValue}]`;

      state.status = `A[${i}] = ${currentValue}. ${get_occurrence_eq} = ${occurrence} occurrence of ${currentValue}. Move ${occurrence} occurrence of ${currentValue} to index ${secondaryState[currentValue]}.`;

      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(secondaryState.slice()); //copy the array and push it into the secondary statelist
    }

    state.barsCountOffset = 0;

    for (var i = 0; i <= maxCountingSortElementValue; ++i) {
      state.entries.pop();
      state.backlinks.pop();
    }

    state.lineNo = 0;
    state.status = 'List is sorted!';
    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(null); // copy the array and push it into the secondary statelist

    this.play(callback);
    return true;
  }

  this.randomizedQuickSort = function(callback) {
    quickSortUseRandomizedPivot = true;
    quickSortStart();

    this.play(callback);
    return true;
  }

  // Returns the depth the object should be in
  function computeYPositionForRecursiveSorts(depth) {
    // each subsequent drop 1 / phi of the prior.
    let ratio = 2 / (1 + Math.sqrt(5));
    let max_scale = 0.9;
    let a = max_scale * (1 - ratio);
    let depth_r = a * (1 - Math.pow(ratio, depth)) / (1 - ratio);
    return (maxHeight + gapBetweenPrimaryAndSecondaryRows) * depth_r;
  }

  function moveYPositionInRange(state, startIndex, endIndex, depth, showFrameByFrame = false) {
      for (var i = startIndex; i < endIndex; i++) {
        if (showRecursionTree) {
          state.backlinks[i].yPosition = computeYPositionForRecursiveSorts(depth);
          state.backlinks[i].secondaryPositionStatus = POSITION_USE_Y_VALUE_PARAM;
        } else {
          state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;
        }
        if (showFrameByFrame === true) {
          StateHelper.updateCopyPush(statelist, state);
        }
      }
  }

  this.quickSort = function(callback) {
    quickSortUseRandomizedPivot = false;
    quickSortStart();

    this.play(callback);
    return true;
  }

  var quickSortStart = function() {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[statelist.length - 1]);

    populatePseudocode([
      'for each (unsorted) partition',
      (quickSortUseRandomizedPivot) ? 'randomly select pivot, swap with first element' : 'set first element as pivot',
      '  storeIndex = pivotIndex+1',
      '  for i = pivotIndex+1 to rightmostIndex',
      '    if ((a[i] &lt; a[pivot]) or (equal but 50% lucky))',
      '      swap(i, storeIndex); ++storeIndex',
      '  swap(pivot, storeIndex-1)'
    ]);

    quickSortSplit(state, 0, numElements-1, 0);

    state.lineNo = 0;
    state.status = 'List is sorted!';

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
    StateHelper.updateCopyPush(statelist, state);
  }

  var quickSortSplit = function(state, startIndex, endIndex, depth) { //startIndex & endIndex inclusive
    var cur_partition = state.backlinks.slice(startIndex, endIndex+1).map(function(d) {
                    return d.value;
                  });
    if (cur_partition.toString().length > 20)
      cur_partition = cur_partition.toString().substr(0, 20)+'...';
    
    moveYPositionInRange(state, startIndex, endIndex + 1, depth);
    state.status = 'Working on partition [{partition}] (index {startIndex} to {endIndex}).'
                  .replace("{partition}", cur_partition)
                  .replace("{startIndex}", startIndex).replace("{endIndex}", endIndex);
    state.lineNo = 1;

    if (startIndex > endIndex)
      return;

    if (startIndex == endIndex) {
      state.status += ' Since partition size == 1, element inside partition is necessarily at sorted position.';
      state.backlinks[startIndex].highlight = HIGHLIGHT_SORTED;
      StateHelper.updateCopyPush(statelist, state);
      return;
    }

    var middleIndex = quickSortPartition(state, startIndex, endIndex);
    quickSortSplit(state, startIndex, middleIndex-1, depth + 1);
    moveYPositionInRange(state, startIndex, middleIndex, depth);
    state.status = `Backtracking to [${startIndex}, ${endIndex}]`;
    state.lineNo = 1;
    StateHelper.updateCopyPush(statelist, state);
    
    quickSortSplit(state, middleIndex+1, endIndex, depth + 1);
    moveYPositionInRange(state, middleIndex + 1, endIndex + 1, depth);
    state.status = `Backtracking to [${startIndex}, ${endIndex}]`;
    state.lineNo = 1;
    StateHelper.updateCopyPush(statelist, state);
  }

  var quickSortPartition = function(state, startIndex, endIndex) {
    var pivotIndex;
    if (quickSortUseRandomizedPivot) {
      pivotIndex = generateRandomNumber(startIndex, endIndex);

      state.status += ' Randomly selected {pivot} (index {index}) as pivot.'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{index}", pivotIndex);
      state.lineNo = [1, 2];

      state.backlinks[pivotIndex].highlight = HIGHLIGHT_PIVOT;
      StateHelper.updateCopyPush(statelist, state);

      if (pivotIndex != startIndex) {
        state.status = 'Swap pivot ({pivot}, index {index}) with first element ({first}, index {firstIndex}). (storeIndex = {storeIndex}.)'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{index}", pivotIndex)
              .replace("{first}", state.backlinks[startIndex].value).replace("{firstIndex}", startIndex).replace("{storeIndex}", (startIndex + 1));

        state.lineNo = [2, 3];

        EntryBacklinkHelper.swapBacklinks(state.backlinks, pivotIndex, startIndex);
        pivotIndex = startIndex;
        StateHelper.updateCopyPush(statelist, state);
      }
    }
    else {
      pivotIndex = startIndex;

      state.status += ' Selecting {pivot} as pivot. (storeIndex = {storeIndex}).'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{storeIndex}", (startIndex + 1));
      state.lineNo = [1, 2, 3];

      state.backlinks[pivotIndex].highlight = HIGHLIGHT_PIVOT;
      StateHelper.updateCopyPush(statelist, state);
    }

    var storeIndex = pivotIndex+1;
    var pivotValue = state.backlinks[pivotIndex].value;

    for (var i = storeIndex; i <= endIndex; ++i) {
      state.status = 'Checking if {val} &lt; {pivot} (pivot) (or if they are equal but 50% lucky).'.replace("{val}", state.backlinks[i].value).replace("{pivot}", pivotValue);
      state.lineNo = [4, 5];

      state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
      StateHelper.updateCopyPush(statelist, state);
      if ((state.backlinks[i].value < pivotValue) || ((state.backlinks[i].value == pivotValue) && (Math.random() < 0.5))) {
        state.status = '{val} &lt;= {pivot} (pivot) is true. Swapping index {idx} (value = {val}) with element at storeIndex {storeIdx} (value = {storeVal}). (Value of storeIndex is now = {newStoreIdx}).'
          .replace("{val}", state.backlinks[i].value)
          .replace("{pivot}", pivotValue)
          .replace("{idx}", i).replace("{storeIdx}", storeIndex)
          .replace("{val}", state.backlinks[i].value)
          .replace("{storeVal}", state.backlinks[storeIndex].value)
          .replace("{newStoreIdx}", (storeIndex+1));
        state.lineNo = [4, 6];

        //if (i != storeIndex) { // small behavioral fix on 12 Feb 2022, swap with itself is animated
          EntryBacklinkHelper.swapBacklinks(state.backlinks, storeIndex, i);
          StateHelper.updateCopyPush(statelist, state);
        //}

        state.backlinks[storeIndex].highlight = HIGHLIGHT_LEFT;
        ++storeIndex;
      }
      else {
        state.backlinks[i].highlight = HIGHLIGHT_RIGHT;
      }
    }
    state.status = 'Iteration complete.';
    state.lineNo = 4;
    StateHelper.updateCopyPush(statelist, state);
    if (storeIndex - 1 != pivotIndex) {
      state.status = 'Swapping pivot (index = {pivotIdx}, value = {pivot}) with element at storeIndex - 1 (index = {newIdx}, value = {newVal}).'.replace("{pivotIdx}", pivotIndex).replace("{pivot}", pivotValue)
            .replace("{newIdx}", (storeIndex - 1)).replace("{newVal}", state.backlinks[storeIndex - 1].value);
      state.lineNo = 7;
      EntryBacklinkHelper.swapBacklinks(state.backlinks, storeIndex - 1, pivotIndex);
      StateHelper.updateCopyPush(statelist, state);
    }

    state.status = 'Pivot is now at its sorted position.';
    state.lineNo = 7;

    for (var i = startIndex; i <= endIndex; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
    state.backlinks[storeIndex - 1].highlight = HIGHLIGHT_SORTED;
    StateHelper.updateCopyPush(statelist, state);

    return storeIndex - 1;
  }

  this.mergeSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'split each element into partitions of size 1',
      'recursively merge adjacent partitions',
      '  for i = leftPartIdx to rightPartIdx',
      '    if leftPartHeadValue <= rightPartHeadValue',
      '      copy leftPartHeadValue',
      '    else: copy rightPartHeadValue' + (computeInversionIndex ? '; Increase InvIdx' : ""),
      'copy elements back to original array'
    ]);

    mergeSortInversionIndexCounter = 0;

    for (var i = 0; i < numElements; ++i) {
      state.backlinks[i].highlight = HIGHLIGHT_RAINBOW[i % 20];
    }
    state.status = 'Chúng ta chia các phần tử thành các mảng có kích thước bằng 1 (mỗi phân vùng có một màu riêng biệt).';
    status.lineNo = 1;
    StateHelper.updateCopyPush(statelist, state);

    this.mergeSortSplitMerge(state, 0, numElements, 0);
    
    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; // unhighlight everything

    state.status = 'Mảng đã được sắp xếp';
    if (computeInversionIndex)
      state.status += '<br>(Inversion Index = {idx}.)'.replace("{idx}", mergeSortInversionIndexCounter);

    state.lineNo = 0;
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.mergeSortSplitMerge = function(state, startIndex, endIndex, depth) { // startIndex inclusive, endIndex exclusive
    if (endIndex - startIndex <= 1)
      return;

    
    moveYPositionInRange(state, startIndex, endIndex, depth);
    state.status = `Đệ quy trên [${startIndex}, ${endIndex - 1}]`;
    StateHelper.updateCopyPush(statelist, state);
    
    var middleIndex = Math.ceil((startIndex + endIndex) / 2);
    this.mergeSortSplitMerge(state, startIndex, middleIndex, depth + 1);

    moveYPositionInRange(state, startIndex, middleIndex, depth);
    state.status = `Quay lại [${startIndex}, ${endIndex - 1}]`;
    StateHelper.updateCopyPush(statelist, state);

    this.mergeSortSplitMerge(state, middleIndex, endIndex, depth + 1);
    
    moveYPositionInRange(state, middleIndex, endIndex, depth);
    state.status = `Quay lại [${startIndex}, ${endIndex - 1}]`;
    StateHelper.updateCopyPush(statelist, state);

    this.mergeSortMerge(state, startIndex, middleIndex, endIndex);
    // Copy array back
    
    state.status = 'Chúng ta sao chép các phần tử từ mảng mới trở lại mảng ban đầu.';
    state.lineNo = 7;

    var duplicateBacklinks = new Array();
    for (var i = startIndex; i < endIndex; ++i) {
      var newPosition = state.backlinks[i].secondaryPositionStatus;
      duplicateBacklinks[newPosition] = state.backlinks[i];
    }

    for (var i = startIndex; i < endIndex; ++i) {
      state.backlinks[i] = duplicateBacklinks[i];
    }
    
    moveYPositionInRange(state, startIndex, endIndex, depth, true);

    StateHelper.updateCopyPush(statelist, state);
  }

  this.mergeSortMerge = function(state, startIndex, middleIndex, endIndex) {
    var leftIndex = startIndex;
    var rightIndex = middleIndex;

    var newHighlightColor = state.backlinks[startIndex].highlight;
    state.status = 'Hợp nhất các phần tử [{partition1}] (từ vị trí {startIdx1} tới vị trí {endIdx1}) và [{partition2}] (từ vị trí {startIdx2} tới {endIdx2}).'
        .replace('{partition1}', state.backlinks.slice(startIndex, middleIndex).map(function(d) {
          return d.value;
        }))
        .replace("{startIdx1}", startIndex).replace("{endIdx1}", (middleIndex - 1))
        .replace("{partition2}", state.backlinks.slice(middleIndex, endIndex).map(function(d) {
          return d.value;
        }))
        .replace("{startIdx2}", middleIndex).replace("{endIdx2}", (endIndex - 1));
    state.lineNo = 2;

    state.backlinks[leftIndex].highlight = makePaler(state.backlinks[leftIndex].highlight);
    state.backlinks[rightIndex].highlight = makePaler(state.backlinks[rightIndex].highlight);
    StateHelper.updateCopyPush(statelist, state);

    for (var i = startIndex; i < endIndex; ++i) {
      // Note here we don't actually copy the elements into a new array, like in a usual mergesort.
      // This is left instead to the mergeSortSplitMerge to handle as it's easier there.
      // (We use the useSecondaryPostion property to overcome this lack-of-copying.)
      if (leftIndex < middleIndex && (rightIndex >= endIndex || state.backlinks[leftIndex].value <= state.backlinks[rightIndex].value)) {
        state.backlinks[leftIndex].highlight = newHighlightColor;
        state.backlinks[leftIndex].secondaryPositionStatus = i;

        if (rightIndex < endIndex) {
          state.status = 'Vì giá trị {leftPart} (phân vùng bên trái &lt;= giá trị {rightPart} (phân vùng bên phải), nên ta lấy {leftPart}.'
            .replace("{leftPart}", state.backlinks[leftIndex].value)
            .replace("{rightPart}", state.backlinks[rightIndex].value)
            .replace("{leftPart}", state.backlinks[leftIndex].value);
        }
        else {
          state.status = 'Vì phân vùng bên phải trống nên chúng ta lấy {leftPart} (phân vùng bên trái).'.replace("{leftPart}", state.backlinks[leftIndex].value);
        }
        state.lineNo = [3, 4, 5];

        leftIndex++;
        if (leftIndex != middleIndex)
          state.backlinks[leftIndex].highlight = makePaler(state.backlinks[leftIndex].highlight);

        StateHelper.updateCopyPush(statelist, state);
      }
      else {
        state.backlinks[rightIndex].highlight = newHighlightColor;
        state.backlinks[rightIndex].secondaryPositionStatus = i;

        if (leftIndex < middleIndex) {
          state.status = 'Vì {leftPart} (phân vùng bên trái) &gt; {rightPart} (phân vùng bên phải), nên chúng ta lấy {rightPart}.'
            .replace("{leftPart}", state.backlinks[leftIndex].value)
            .replace("{rightPart}", state.backlinks[rightIndex].value)
            .replace("{rightPart}", state.backlinks[rightIndex].value);
        }
        else {
          state.status = 'Vì phân vùng bên trái trống nên chúng ta lấy {rightPart} (phân vùng bên phải).'.replace("{rightPart}", state.backlinks[rightIndex].value);
        }

        if (computeInversionIndex) {
          mergeSortInversionIndexCounter += middleIndex - leftIndex;
          state.status += '<br>(Chúng ta tăng thêm kích thước của phân vùng bên trái (= {sizeofleft}) tới <b>InvIdx&nbsp;</b>({inversionidxcounter}).)'
            .replace("{sizeofleft}", (middleIndex - leftIndex)).replace("{inversionidxcounter}", mergeSortInversionIndexCounter);
        }
//        else {
//          state.status += 'weird'; // what is this?
//        }
        state.lineNo = [3, 6];

        ++rightIndex;
        if (rightIndex != endIndex)
          state.backlinks[rightIndex].highlight = makePaler(state.backlinks[rightIndex].highlight);

        StateHelper.updateCopyPush(statelist, state);
      }
    }
  }

  this.insertionSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'mark first element as sorted',
      'for each unsorted element X',
      '  &#39;extract&#39; the element X',
      '  for j = lastSortedIndex down to 0',
      '    if current element j &gt; X',
      '      move sorted element to the right by 1',
      '    break loop and insert X here'
    ]);

    // First element always sorted
    state.lineNo = 1;
    // Mark the first element ({firstVal}) as sorted.
    state.status = 'Mark index 0 ({firstVal}) as sorted.'.replace("{firstVal}", state.backlinks[0].value);
    // state.status = 'Mark the first element ({firstVal}) as sorted.'.replace("{firstVal}", state.backlinks[0].value);
    state.backlinks[0].highlight = HIGHLIGHT_SORTED;
    StateHelper.updateCopyPush(statelist, state);

    for (var i = 1; i < numElements; ++i) {
      // Highlight first unsorted element
      state.lineNo = [2, 3];
      // Extract the first unsorted element ({val}).
      state.status = 'Extract the first unsorted element at index {idx} ({val}).'.replace("{idx}", i).replace("{val}", state.backlinks[i].value);
      // state.status = 'Extract the first unsorted element ({val}).'.replace("{val}", state.backlinks[i].value);
      state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
      state.backlinks[i].secondaryPositionStatus = POSITION_USE_SECONDARY_IN_DEFAULT_POSITION;
      StateHelper.updateCopyPush(statelist, state);

      for (var j = i-1; j >= 0; --j) {
        state.lineNo = 4;
        // Figure where to insert extracted element.
        // Comparing with sorted element {val}.
        state.status = 'Figure where to insert extracted element. Comparing with sorted element at index {idx} ({val}).'.replace("{idx}", j).replace("{val}", state.backlinks[j].value);
        // state.status = 'Figure where to insert extracted element; comparing with sorted element {val}.'.replace("{val}", state.backlinks[j].value);
        state.backlinks[j].highlight = HIGHLIGHT_STANDARD;
        StateHelper.updateCopyPush(statelist, state);

        if (state.backlinks[j].value > state.backlinks[j+1].value) {
          state.lineNo = [5, 6];
          // {val1} > {val2} is true.
          // Hence move current sorted element ({val1}) to the right by 1.
          state.status = '{val1} > {val2} is true, hence move current sorted element ({val1}) to the right by 1 to index {idx}.'
                          .replace("{val1}", state.backlinks[j].value)
                          .replace("{val2}", state.backlinks[j+1].value)
                          .replace("{val1}", state.backlinks[j].value)
                          .replace("{idx}", j+1);
          // state.status = '{val1} > {val2} is true, hence move current sorted element ({val1}) to the right by 1.'.replace("{val1}", state.backlinks[j].value).replace("{val2}", state.backlinks[j+1].value).replace("{val1}", state.backlinks[j].value);
          EntryBacklinkHelper.swapBacklinks(state.backlinks, j, j+1);
          StateHelper.updateCopyPush(statelist, state);
          state.backlinks[j+1].highlight = HIGHLIGHT_SORTED;
        }
        else {
          state.lineNo = 7;
          // {val1} > {val2} is false.
          // Insert extracted element at current position.
          state.status = '{val1} > {val2} is false. Insert extracted element at current position (index {idx}).'
                          .replace("{val1}", state.backlinks[j].value)
                          .replace("{val2}", state.backlinks[j+1].value)
                          .replace("{idx}", j+1);
          // state.status = '{val1} > {val2} is false, insert element at current position.'.replace("{val1}", state.backlinks[j].value).replace("{val2}", state.backlinks[j+1].value);
          state.backlinks[j].highlight = HIGHLIGHT_SORTED;
          state.backlinks[j+1].secondaryPositionStatus = POSITION_USE_PRIMARY;
          state.backlinks[j+1].highlight = HIGHLIGHT_SORTED;
          StateHelper.updateCopyPush(statelist, state);
          break;
        }
      }

      if (state.backlinks[0].secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION) {
        state.lineNo = 4;
        // At beginning of array (nothing to compare).
        // Hence insert extracted element at current position.
        state.status = 'At index 0 (nothing to compare). Hence insert extracted element at current position (index 0).';
        // state.status = 'At beginning of array (nothing to compare), hence insert element at current position.';
        state.backlinks[0].secondaryPositionStatus = POSITION_USE_PRIMARY;
        state.backlinks[0].highlight = HIGHLIGHT_SORTED;
        StateHelper.updateCopyPush(statelist, state);
      }
    }

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
    state.lineNo = 0;
    // The array/list is now sorted.
    state.status = 'List is sorted!';
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.selectionSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'repeat (numOfElements - 1) times',
      '  set the first unsorted element as the minimum',
      '  for each of the unsorted elements',
      '    if element < currentMinimum',
      '      set element as new minimum',
      '  swap minimum with first unsorted position'
    ]);

    for (var i = 0; i < numElements-1; ++i) {
      var minPosition = i;

      // Iteration {iteration}: Set {val} as the current minimum.
      // Then iterate through the rest to find the true minimum.
      state.status = 'Iteration {iteration}: Set {val} as the current minimum, then iterate through the remaining unsorted elements to find the true minimum.'.replace("{iteration}", (i+1)).replace("{val}", state.backlinks[i].value);
      state.lineNo = [1, 2, 3];
      state.backlinks[minPosition].highlight = HIGHLIGHT_SPECIAL;

      StateHelper.updateCopyPush(statelist, state);

      for (var j = i+1; j < numElements; ++j) {
        // Check if {val} is smaller than the current minimum ({minVal}).
        state.status = 'Check if {val} is smaller than the current minimum ({minVal}).'.replace("{val}", state.backlinks[j].value).replace("{minVal}", state.backlinks[minPosition].value);
        state.lineNo = 4;
        state.backlinks[j].highlight = HIGHLIGHT_STANDARD;
        StateHelper.updateCopyPush(statelist, state);

        state.backlinks[j].highlight = HIGHLIGHT_NONE;

        if (state.backlinks[j].value < state.backlinks[minPosition].value) {
          state.status = 'Set {val} as the new minimum.'.replace("{val}", state.backlinks[j].value);
          state.lineNo = 5;
          state.backlinks[minPosition].highlight = HIGHLIGHT_NONE;
          state.backlinks[j].highlight = HIGHLIGHT_SPECIAL;

          minPosition = j;
          StateHelper.updateCopyPush(statelist, state);
        }
      }

      if (minPosition != i) { // Highlight the first-most unswapped position, if it isn't the minimum
        // Set {val} as the new minimum.
        state.status = 'Swap the minimum {minVal} at index {idx1} with the first unsorted element (47) at index {idx2}.'.replace("{minVal}", state.backlinks[minPosition].value).replace("{element}", state.backlinks[i].value).replace("{idx1}", minPosition).replace("{idx2}", i);
        // state.status = 'Swap the minimum ({minVal}) with the first unsorted element ({element}).'.replace("{minVal}", state.backlinks[minPosition].value).replace("{element}", state.backlinks[i].value);
        state.lineNo = 6;
        state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
        StateHelper.updateCopyPush(statelist, state);

        EntryBacklinkHelper.swapBacklinks(state.backlinks, minPosition, i);
        StateHelper.updateCopyPush(statelist, state);
      }
      else {
        // As the minimum is the first unsorted element, no swap is necessary.
        state.status = 'As the minimum is the first unsorted element, no swap is necessary.';
        state.lineNo = 6;
        StateHelper.updateCopyPush(statelist, state);
      }

      // {val} is now considered sorted.
      state.status = '{val} is now considered sorted.'.replace("{val}", state.backlinks[i].value);
      state.backlinks[minPosition].highlight = HIGHLIGHT_NONE;
      state.backlinks[i].highlight = HIGHLIGHT_SORTED;
      StateHelper.updateCopyPush(statelist, state);
    }

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; // un-highlight everything
    // The array/list is now sorted.
    // (After all iterations, the last element will naturally be sorted.)
    state.status = 'List is sorted!' + '<br>' + '(After all iterations, the last element will naturally be sorted.)';
    status.lineNo = 0;
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.bubbleSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);
    var swapCounter = 0;

    populatePseudocode([
      'do',
      '  <b>swapped </b>= false',
      '  for i = 1 to indexOfLastUnsortedElement-1',
      '    if leftElement > rightElement',
      '      swap(leftElement, rightElement)',
      '      <b>swapped </b>= true' + (computeInversionIndex ? '; <b>++swapCounter</b>' : ""),
      'while <b>swapped</b>'
    ]);

    var swapped;
    var indexOfLastUnsortedElement = numElements;
    do {
      swapped = false;

      // Set the swapped flag to false.
      // Then iterate from 1 to {endIdx} inclusive.
      state.status = 'Set the <b>swapped </b>flag to false.<div>Then iterate from index 1 to {endIdx} inclusive.</div>'.replace("{endIdx}", indexOfLastUnsortedElement-1);
      state.lineNo = [2, 3];
      StateHelper.updateCopyPush(statelist, state);

      for (var i = 1; i < indexOfLastUnsortedElement; ++i) {
        state.backlinks[i-1].highlight = HIGHLIGHT_STANDARD;
        state.backlinks[i].highlight = HIGHLIGHT_STANDARD;

        // Checking if {val1} > {val2} and swap them if that is true.
        // The current value of swapped = {swapped}.
        state.status = '<div>Checking if {val1} &gt; {val2} and swap them if that is true;&nbsp;<b>swapped </b>= {swapped}.</div>'.replace("{val1}", `${state.backlinks[i-1].value} (index ${i-1})`).replace("{val2}", `${state.backlinks[i].value} (index ${i})`).replace("{swapped}", swapped);
        state.lineNo = 4;
        StateHelper.updateCopyPush(statelist, state);

        if (state.backlinks[i-1].value > state.backlinks[i].value) {
          swapped = true;

          // Swapping the positions of {val1} and {val2}.
          // Set swapped = true.
          state.status = 'Swapping the index {idx1} and index {idx2} and set swapped = true.'.replace("{idx1}", i-1).replace("{idx2}", i);
          // state.status = 'Swapping the positions of {val1} and {val2} and set <b>swapped </b>= true.'.replace("{val1}", state.backlinks[i-1].value).replace("{val2}", state.backlinks[i].value);
          if (computeInversionIndex) {
            ++swapCounter;
            // For inversion index computation: Add 1 to swapCounter.
            // The current value of swapCounter = {swapCounter}.
            state.status += '<br>For inversion index: Add 1 to <b>swapCounter</b>, now = {swapCounter}.'.replace("{swapCounter}", swapCounter);
          }

          state.lineNo = [5, 6];

          EntryBacklinkHelper.swapBacklinks(state.backlinks, i, i-1);
          StateHelper.updateCopyPush(statelist, state);
        }

        state.backlinks[i-1].highlight = HIGHLIGHT_NONE;
        state.backlinks[i].highlight = HIGHLIGHT_NONE;
      }

      --indexOfLastUnsortedElement;
      state.backlinks[indexOfLastUnsortedElement].highlight = HIGHLIGHT_SORTED;
      if (swapped == false)
        // No swap is done in this pass.
        // We can terminate Bubble Sort now.
        state.status = 'No swap is done in this pass.<div>We can terminate Bubble Sort now</div>';
      else
        // Mark last unsorted element as sorted now.
        // As at least one swap is done in this pass, we continue.
        state.status = '<div>Mark this element as sorted now.</div><div>As at least one swap is done in this pass, we continue.</div>';

      state.lineNo = 7;
      StateHelper.updateCopyPush(statelist, state);
    }
    while (swapped);

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //un-highlight everything

    // The array/list is now sorted.
    state.status = 'List is sorted!';
    if (computeInversionIndex)
      // Inversion Index = {swapCounter}.
      state.status += '<br>Inversion Index = {swapCounter}.'.replace("{swapCounter}", swapCounter);

    state.lineNo = 0;
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.clearPseudocode = function() { populatePseudocode([]); }

  var populatePseudocode = function(code) {
    var i = 1;
    for (; i <= 7 && i <= code.length; ++i) {
      $("#code" + i).html(
        code[i - 1].replace(
        /^\s+/,
        function(m) { return m.replace(/\s/g, "&nbsp;"); }
        )
      );
    }
    for (; i <= 7; ++i) {
      $("#code" + i).html("");
    }
  }

  //animation functions
  var drawCurrentState = function() {
    if (currentStep < 0)
      currentStep = 0;
    if (currentStep > statelist.length - 1)
      currentStep = statelist.length - 1;
    $('#progress-bar').slider("value", currentStep);
    drawState(currentStep);
    if (currentStep == (statelist.length-1)) {
      pause(); //in html file
      $('#play img').attr('src', 'https://visualgo.net/img/replay.png').attr('alt', 'replay').attr('title', 'replay');
    }
    else
      $('#play img').attr('src', 'https://visualgo.net/img/play.png').attr('alt', 'play').attr('title', 'play');
  }

  this.getAnimationDuration = function() { return transitionTime; }

  this.setAnimationDuration = function(x) {
    transitionTime = x;
    if (issPlaying) {
      clearInterval(animInterval);
      animInterval = setInterval(function() {
        drawCurrentState();
        if (currentStep < (statelist.length-1))
          ++currentStep;
        else
          clearInterval(animInterval);
      }, transitionTime);
    }
  }

  this.getCurrentIteration = function() { return currentStep; }

  this.getTotalIteration = function() { return statelist.length; }

  this.forceNext = function() {
    if ((currentStep + 1) < statelist.length)
      ++currentStep;
    drawCurrentState();
  }

  this.forcePrevious = function() {
    if ((currentStep-1) >= 0)
      --currentStep;
    drawCurrentState();
  }

  this.jumpToIteration = function(n) {
    currentStep = n;
    drawCurrentState();
  }

  this.play = function(callback) {
    issPlaying = true;
    drawCurrentState();
    animInterval = setInterval(function() {
      drawCurrentState();
      if (currentStep < (statelist.length-1))
        ++currentStep;
      else {
        clearInterval(animInterval);
        if (typeof callback == 'function') callback();
      }
    }, transitionTime);
  }

  this.pause = function() {
    issPlaying = false;
    clearInterval(animInterval);
  }

  this.replay = function() {
    issPlaying = true;
    currentStep = 0;
    drawCurrentState();
    animInterval = setInterval(function() {
      drawCurrentState();
      if (currentStep < (statelist.length-1))
        currentStep++;
      else
        clearInterval(animInterval);
    }, transitionTime);
  }

  this.stop = function() {
    issPlaying = false;
    statelist = [statelist[0]]; //clear statelist to original state, instead of new Array();
    secondaryStatelist = [null];
    currentStep = 0;
    drawState(0);
  }

  this.isSelectedSortFunctionRecursive = function() {
    return this.selectedSortFunction == gw.mergeSort
      || this.selectedSortFunction == gw.quickSort
      || this.selectedSortFunction == gw.randomizedQuickSort;
  }

  this.setShowRecursionTreeFlag = function(newFlag) {
    if (newFlag !== true && newFlag !== false) {
      console.warn(`Attempted to set unknown recursion tree flag: ${newFlag}. Parameter ignored`);
      return;
    }
    showRecursionTree = newFlag;
  }
}

// sorting action
var actionsWidth = 150;
var statusCodetraceWidth = 420;

//this viz-specific code
var gw = new Sorting();

// local
$(function() {
  gw.setAnimationDuration(700 / speedVal);
  AbbreviateTitle();
  var eight_modes = ["Bubble", "Selection", "Insertion", "Merge", "Quick", "RandomizedQuick", "Counting", "Radix"];
  $('#title-'+eight_modes[Math.floor(Math.random()*8)]).click(); // randomly open one of the eight sorting algorithm mode every time
  $('#play').hide();

  d3.selectAll("#radix-sort-bucket-labels-collection span")
    .style({"left": function(d, i) {
                  return 17.5 + i * 65 + "px";
          }});
  var sortMode = getQueryVariable("mode");
  if (sortMode.length > 0) {
     $('#title-' + sortMode).click();
  }
  var createArray = getQueryVariable("create");
  if (createArray.length > 0) {
    $('#userdefined-input').val(createArray);
    createList("userdefined");
  }

});

const DEFAULT_COUNT_DATA = "2,3,8,7,1,2,2,2,7,3,9,8,2,1,4"; // drop 5 numbers on 25 Feb , 2, 4, 6, 9, 2";
const DEFAULT_RADIX_DATA = "3221, 1, 10, 9680, 577, 9420, 7, 5622, 4793, 2030, 3138, 82, 2599, 743, 4127";

// title changing
function AbbreviateTitle() {
  $('#title-Merge').text("Merge Sort").attr('title', 'Merge Sort');
}

// Function to start the Merge Sort and hide options
function startMergeSort() {
  hideAllCanvases();               // Ẩn tất cả canvas
  hideAllSortingOptions();         // Ẩn tất cả các lựa chọn sắp xếp
  $("#sort-bubble-merge-inversion").css("display", ""); // Hiển thị canvas cho Merge Sort
  $('#current-action p').html('Merge Sort'); // Cập nhật thông tin hành động
  displayRecursiveOptions();      // Hiển thị các tùy chọn đệ quy
  changeSortType(gw.mergeSort);   // Đổi loại sắp xếp sang Merge Sort
  showStandardCanvas();           // Hiển thị canvas chuẩn
  AbbreviateTitle();              // Thay đổi tiêu đề
  $('#title-Merge').text('Merge Sort'); // Cập nhật tiêu đề
}

// Gọi trực tiếp hàm startMergeSort() để thực thi mà không cần click vào tiêu đề
startMergeSort();



function changeSortType(newSortingFunction, customNumberList) {
  if (!customNumberList) {
    createList('random');
  }
  else {
    $('#userdefined-input').val(customNumberList);
    createList('userdefined');
  }

  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  gw.clearPseudocode();
  gw.setSelectedSortFunction(newSortingFunction);
}

function allOff() {
  $("#counting-simple").css("display", "none");
  $("#counting-stable").css("display", "none");
  $("#recursive-show-depth").css("display", "none");
  $("#recursive-hide-depth").css("display", "none");
  $("#create-userdefined-input-cs").css("display", "none");
  $("#create-userdefined-go-cs").css("display", "none");
  $("#create-userdefined-input-rs").css("display", "none");
  $("#create-userdefined-go-rs").css("display", "none");
}

function displayRecursiveOptions() {
  allOff();

  $("#recursive-show-depth").css("display", "");
  $("#recursive-hide-depth").css("display", "");
}

function displayCounting() {
  allOff();

  $("#counting-simple").css("display", "");
  $("#counting-stable").css("display", "");
  $("#create-userdefined-input-cs").css("display", "");
  $("#create-userdefined-go-cs").css("display", "");
}

function displayRadix() {
  allOff();

  $("#create-userdefined-input-rs").css("display", "");
  $("#create-userdefined-go-rs").css("display", "");
}

function createList(type) {
  if (isPlaying) stop();

  var arr_size = parseInt($("#user-arr-size").val());

  setTimeout(function() {
    if (gw.createList(type, arr_size)) {
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 0);
}

function setBase() {
  if (isPlaying) stop();
  var input = (gw.selectedSortFunction === gw.countingSort)
                ? parseInt($("#counting-sort-base").val())
                : parseInt($("#radix-sort-base").val());

  var setBaseSuccessfully = (gw.selectedSortFunction === gw.countingSort)
                              ? gw.setCountingSortBase(input)
                              : gw.setRadixSortBase(input);

  if (setBaseSuccessfully) {
    // once the base is being changed, create a random list within the new range to show the user that the change is successful
    createList("random");
  }
}

function sort(callback) {
  gw.computeInversionIndex = $('#sort-bubble-merge-inversion-checkbox').prop('checked');
  if (isPlaying) stop();
  setTimeout(function() {
    if (gw.sort(callback)) {
      $('#current-action').show();
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 0);
}

function sortGeneric(callback) {
  if (gw.selectedSortFunction != gw.countingSort
      && !gw.isSelectedSortFunctionRecursive()) {
    sort();
  }
}

function recursiveSort(showRecursionTree, callback) {
  if (isPlaying) stop();
  setTimeout(function() {
    // I don't like the design of this, but again, it's the cleanest way to get this working.
    gw.setShowRecursionTreeFlag(showRecursionTree);
    if (gw.sort(callback)) {
      $('#current-action').show();
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 0);
}

function countingSortStable(callback) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (gw.countingSortStable(callback)) {
      $('#current-action').show();
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 0);
}

// sort options
function hideAllSortingOptions() {
  $("#sort-bubble-merge-inversion").css("display", "none");
}

// canvas
function hideAllCanvases() {
  $("#viz").hide();
  $("#viz-counting-sort-secondary-canvas").hide();
  $("#viz-sort-index-canvas").hide();
  $("#viz-radix-sort-canvas").hide();
}

function showStandardCanvas() {
  $("#viz").show();
  $("#viz-sort-index-canvas").hide();
  $("#viz-counting-sort-secondary-canvas").hide(); 
  $("#viz-radix-sort-canvas").hide();
}

function setDefaultScale() { // sets the sorting visualisation to its default scale (max 15 elements)
  gw.changeBarWidth(50);
  $('#scale').html('1.0x');
  // TODO (Berted): I hate that I'm doing this, but it's the easiest way to resolve this bar-none.
  $("#viz-counting-sort-secondary-canvas").css("top", "-500px");
  $('#viz-sort-index-canvas').show();
}

function setMediumScale() { // sets the sorting visualisation to a smaller scale to accomodate more elements (around 60)
  gw.changeBarWidth(21); // 13
  $('#scale').html('0.5x');
  $("#viz-counting-sort-secondary-canvas").css("top", "-165px");
  $('#viz-sort-index-canvas').hide();
}

var exploreModeData = [];

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  exploreModeData = gw.currentNumList;
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  gw.loadNumberList(exploreModeData);
}

// Lecture action functions
function SORT(mode) {
  hideSlide(function() {
    sort(showSlide);
  });
}
function CUSTOM_ACTION(action, data, mode) {}
</script>
  </body>
</html>
